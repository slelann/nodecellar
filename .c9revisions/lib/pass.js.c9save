{"ts":1371655259499,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":true,"ts":1371655262103,"patch":[[{"diffs":[[1,"// check out https://github.com/visionmedia/node-pwd\n\n/**\n* Module dependencies.\n*/\n\nvar crypto = require('crypto');\n\n/**\n* Bytesize.\n*/\n\nvar len = 128;\n\n/**\n* Iterations. ~300ms\n*/\n\nvar iterations = 12000;\n\n/**\n* Hashes a password with optional `salt`, otherwise\n* generate a salt for `pass` and invoke `fn(err, salt, hash)`.\n*\n* @param {String} password to hash\n* @param {String} optional salt\n* @param {Function} callback\n* @api public\n*/\n\nexports.hash = function (pwd, salt, fn) {\n  if (3 == arguments.length) {\n    crypto.pbkdf2(pwd, salt, iterations, len, function(err, hash){\n      fn(err, (new Buffer(hash, 'binary')).toString('base64'));\n    });\n  } else {\n    fn = salt;\n    crypto.randomBytes(len, function(err, salt){\n      if (err) return fn(err);\n      salt = salt.toString('base64');\n      crypto.pbkdf2(pwd, salt, iterations, len, function(err, hash){\n        if (err) return fn(err);\n        fn(null, salt, (new Buffer(hash, 'binary')).toString('base64'));\n      });\n    });\n  }\n};"]],"start1":0,"start2":0,"length1":0,"length2":998}]],"length":998,"saved":false}
{"contributors":[],"silentsave":true,"ts":1371657220591,"patch":[[{"diffs":[[-1,"// check out https://github.com/visionmedia/node-pwd\n\n"],[0,"/**\n"]],"start1":0,"start2":0,"length1":58,"length2":4}]],"length":944,"saved":false}
{"ts":1371657227437,"patch":[[{"diffs":[[0,"dencies.\n*/\n"],[-1,"\n"],[0,"var crypto ="]],"start1":18,"start2":18,"length1":25,"length2":24}]],"length":943,"saved":false}
