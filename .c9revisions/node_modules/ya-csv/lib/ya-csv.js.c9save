{"ts":1377520320443,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var sys;\ntry {\n  sys    = require('util'); \n} catch (e) {\n  sys    = require('sys');\n}\nvar events = require('events'),\n    fs     = require('fs');\n\nvar csv = exports;\n\n/**\n * Provides Base CSV Reading capabilities\n * @class CsvReader\n * @extends EventEmitter\n */\n\n/**\n * The constructor\n * @constructor\n * @param readStream {ReadStread} An instance of the ReadStream Cl\n * @param options {Object} optional paramaters for the reader <br/>\n *     - separator {String}\n *     - quote {String}\n *     - escape {String}\n *     - comment {String}\n *     - columnNames {Boolean}\n *     - columnsFromHeader {Boolean}\n *     - nestedQuotes {Boolean}\n */\nvar CsvReader = csv.CsvReader = function(readStream, options) {\n    var self = this;\n    _setOptions(self, options);\n\n    self.parsingStatus = {\n        rows:          0,\n        openRecord:    [],\n        openField:     '',\n        lastChar:      '',\n        quotedField:   false,\n        commentedLine: false\n    };\n\n    if (readStream) {\n        readStream.addListener('data', this.parse.bind(this));\n        readStream.addListener('error', this.emit.bind(this, 'error'));\n        readStream.addListener('end', this.end.bind(this));\n\n\n        /**\n         * Pauses the readStream\n         * @method pause\n         * @return {ReadStream} the readstream instance\n         */\n        self.pause = function(){\n            readStream.pause();\n            return self;\n        }\n\n        /**\n         * Resumes the readStream\n         * @method resume\n         * @return {ReadStream} the readstream instance\n         */\n        self.resume = function(){\n            readStream.resume();\n            return self;\n        }\n\n        /**\n         * Closes the readStream\n         * @method destroy\n         * @return {ReadStream} the readstream instance\n         */\n        self.destoy = function(){\n            readStream.destroy();\n            return self;\n        }\n\n        /**\n         * Closes the readStream when its file stream has been drained\n         * @method destroySoon\n         * @return {ReadStream} the readstream instance\n         */\n        self.destroySoon = function(){\n            readstream.destroy();\n            return self;\n        }\n    }\n\n};\nsys.inherits(CsvReader, events.EventEmitter);\n\n/**\n * Parses incoming data as a readable CSV file\n * @method parse\n * @param data {Array} Array of values to parse from the incommin file\n */\nCsvReader.prototype.parse = function(data) {\n    var ps = this.parsingStatus;\n    if (ps.openRecord.length == 0) {\n        if (data.charCodeAt(0) === 0xFEFF) {\n            data = data.slice(1);\n        }\n    }\n    for (var i = 0; i < data.length; i++) {\n        var c = data.charAt(i);\n        switch (c) {\n            // escape and separator may be the same char, typically '\"'\n            case this.escapechar:\n            case this.quotechar:\n                if (ps.commentedLine) break;\n                var isEscape = false;\n                if (c === this.escapechar) {\n                    var nextChar = data.charAt(i + 1);\n                    if (this._isEscapable(nextChar)) {\n                        this._addCharacter(nextChar);\n                        i++;\n                        isEscape = true;\n                    }\n                }\n                if (!isEscape && (c === this.quotechar)) {\n                    if (ps.openField && !ps.quotedField) {\n                        ps.quotedField = true;\n                        break;\n                    }\n                    if (ps.quotedField) {\n                        // closing quote should be followed by separator unless the nested quotes option is set\n                        var nextChar = data.charAt(i + 1);\n                        if (nextChar && nextChar != '\\r' && nextChar != '\\n' && nextChar !== this.separator && this.nestedQuotes != true) {\n                            throw new Error(\"separator expected after a closing quote; found \" + nextChar);\n                        } else {\n                            ps.quotedField = false;\n                        }\n                    } else if (ps.openField === '') {\n                        ps.quotedField = true;\n                    }\n                }\n                break;\n            case this.separator:\n                if (ps.commentedLine) break;\n                if (ps.quotedField) {\n                    this._addCharacter(c);\n                } else {\n                    this._addField();\n                }\n                break;\n            case '\\n':\n                // handle CRLF sequence\n                if (!ps.quotedField && (ps.lastChar === '\\r')) {\n                    break;\n                }\n            case '\\r':\n                if (ps.commentedLine) {\n                    ps.commentedLine = false;\n                } else if (ps.quotedField) {\n                    this._addCharacter(c);\n                } else {\n                    this._addField();\n                    this._addRecord();\n                }\n                break;\n            case this.commentchar:\n                if (ps.commentedLine) break;\n                if (ps.openRecord.length === 0 && ps.openField === '' && !ps.quotedField) {\n                    ps.commentedLine = true;\n                } else {\n                    this._addCharacter(c);\n                }\n            default:\n                if (ps.commentedLine) break;\n                this._addCharacter(c);\n        }\n        ps.lastChar = c;\n    }\n};\n\n\nCsvReader.prototype.end = function() {\n    var ps = this.parsingStatus;\n    if (ps.quotedField) {\n        this.emit('error', new Error('Input stream ended but closing quotes expected'));\n    } else {\n        // dump open record\n        if (ps.openField) {\n            this._addField();\n        }\n        if (ps.openRecord.length > 0) {\n            this._addRecord();\n        }\n        this.emit('end');\n    }\n}\nCsvReader.prototype._isEscapable = function(c) {\n    if ((c === this.escapechar) || (c === this.quotechar)) {\n        return true;\n    }\n    return false;\n};\n\nCsvReader.prototype._addCharacter = function(c) {\n    this.parsingStatus.openField += c;\n};\n\nCsvReader.prototype._addField = function() {\n    var ps = this.parsingStatus;\n    ps.openRecord.push(ps.openField);\n    ps.openField = '';\n    ps.quotedField = false;\n};\n\nCsvReader.prototype.setColumnNames = function(names) {\n    this.columnNames = names;\n};\n\nCsvReader.prototype._addRecord = function() {\n    var ps = this.parsingStatus;\n    if (this.columnsFromHeader && ps.rows === 0) {\n        this.setColumnNames(ps.openRecord);\n    } else if (this.columnNames != null && this.columnNames.length > 0) {\n        var objResult = {};\n        for (var i = 0; i < this.columnNames.length; i++) {\n            objResult[this.columnNames[i]] = ps.openRecord[i];\n        }\n        this.emit('data', objResult);\n    } else {\n        this.emit('data', ps.openRecord);\n    }\n    ps.rows++;\n    ps.openRecord = [];\n    ps.openField = '';\n    ps.quotedField = false;\n};\n\ncsv.createCsvFileReader = function(path, options) {\n    options = options || {};\n    var readStream = fs.createReadStream(path, {\n        'flags': options.flags || 'r'\n    });\n    readStream.setEncoding(options.encoding || 'utf8');\n    return new CsvReader(readStream, options);\n};\n\ncsv.createCsvStreamReader = function(readStream, options) {\n    if (options === undefined && typeof readStream === 'object') {\n        options = readStream;\n        readStream = undefined;\n    }\n    options = options || {};\n    if (readStream) readStream.setEncoding(options.encoding || 'utf8');\n    return new CsvReader(readStream, options);\n};\n\nvar CsvWriter = csv.CsvWriter = function(writeStream, options) {\n    var self = this;\n    self.writeStream = writeStream;\n    options = options || {};\n    _setOptions(self, options);\n    self.encoding = options.encoding || 'utf8';\n\n    if (typeof writeStream.setEncoding === 'function') {\n        writeStream.setEncoding(self.encoding);\n    }\n\n    writeStream.addListener('drain', this.emit.bind(this, 'drain'));\n    writeStream.addListener('error', this.emit.bind(this, 'error'));\n    writeStream.addListener('close', this.emit.bind(this, 'close'));\n};\nsys.inherits(CsvWriter, events.EventEmitter);\n\nCsvWriter.prototype.writeRecord = function(rec) {\n    if (!rec) return; // ignore empty records\n    if (!Array.isArray(rec)) {\n        throw new Error(\"CsvWriter.writeRecord only takes an array as an argument\");\n    }\n    _writeArray(this, rec);\n};\n\nfunction _writeArray(writer, arr) {\n    var out = [];\n    for (var i = 0; i < arr.length; i++) {\n        if (i != 0) out.push(writer.separator);\n        out.push(writer.quotechar);\n        _appendField(out, writer, arr[i]);\n        out.push(writer.quotechar);\n    }\n    out.push(\"\\r\\n\");\n    writer.writeStream.write(out.join(''), this.encoding);\n};\n\nfunction _appendField(outArr, writer, field) {\n    // Make sure field is a string\n    if(typeof(field) !== 'string') {\n      // We are not interested in outputting \"null\" or \"undefined\"\n      if(typeof(field) !== 'undefined' && field !== null) {\n        field = String(field);\n      } else {\n        outArr.push('');\n        return;\n      }\n    }\n\n    for (var i = 0; i < field.length; i++) {\n        if (field.charAt(i) === writer.quotechar || field.charAt(i) === writer.escapechar) {\n            outArr.push(writer.escapechar);\n        }\n        outArr.push(field.charAt(i));\n    }\n};\n\ncsv.createCsvFileWriter = function(path, options) {\n    options = options || {'flags': 'w'};\n    var writeStream = fs.createWriteStream(path, {\n        'flags': options.flags || 'w'\n    });\n    return new CsvWriter(writeStream, options);\n};\n\ncsv.createCsvStreamWriter = function(writeStream, options) {\n    return new CsvWriter(writeStream, options);\n};\n\n// ===============\n// =   utils     =\n// ===============\n\nfunction _setOptions(obj, options) {\n    options = options || {};\n    obj.separator   = options.separator   || ',';\n    obj.quotechar   = options.quote       || '\"';\n    obj.escapechar  = options.escape      || '\"';\n    obj.commentchar = options.comment     || '';\n    obj.columnNames = options.columnNames || [];\n    obj.columnsFromHeader = options.columnsFromHeader || false;\n    obj.nestedQuotes = options.nestedQuotes || false;\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":10224}]],"length":10224}
