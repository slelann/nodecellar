{"ts":1377767026777,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/* Copyright (C) 1999-2003, 2005-2006, 2008-2011 Free Software Foundation, Inc.\n   This file is part of the GNU LIBICONV Library.\n\n   The GNU LIBICONV Library is free software; you can redistribute it\n   and/or modify it under the terms of the GNU Library General Public\n   License as published by the Free Software Foundation; either version 2\n   of the License, or (at your option) any later version.\n\n   The GNU LIBICONV Library is distributed in the hope that it will be\n   useful, but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n\n   You should have received a copy of the GNU Library General Public\n   License along with the GNU LIBICONV Library; see the file COPYING.LIB.\n   If not, write to the Free Software Foundation, Inc., 51 Franklin Street,\n   Fifth Floor, Boston, MA 02110-1301, USA.  */\n\n/* When installed, this file is called \"iconv.h\". */\n\n#ifndef _LIBICONV_H\n#define _LIBICONV_H\n\n#define _LIBICONV_VERSION 0x010E    /* version number: (major<<8) + minor */\nextern int _libiconv_version; /* Likewise */\n\n/* We would like to #include any system header file which could define\n   iconv_t, 1. in order to eliminate the risk that the user gets compilation\n   errors because some other system header file includes /usr/include/iconv.h\n   which defines iconv_t or declares iconv after this file, 2. when compiling\n   for LIBICONV_PLUG, we need the proper iconv_t type in order to produce\n   binary compatible code.\n   But gcc's #include_next is not portable. Thus, once libiconv's iconv.h\n   has been installed in /usr/local/include, there is no way any more to\n   include the original /usr/include/iconv.h. We simply have to get away\n   without it.\n   Ad 1. The risk that a system header file does\n   #include \"iconv.h\"  or  #include_next \"iconv.h\"\n   is small. They all do #include <iconv.h>.\n   Ad 2. The iconv_t type is a pointer type in all cases I have seen. (It\n   has to be a scalar type because (iconv_t)(-1) is a possible return value\n   from iconv_open().) */\n\n/* Define iconv_t ourselves. */\n#undef iconv_t\n#define iconv_t libiconv_t\ntypedef void* iconv_t;\n\n/* Get size_t declaration.\n   Get wchar_t declaration if it exists. */\n#include <stddef.h>\n\n/* Get errno declaration and values. */\n#include <errno.h>\n/* Some systems, like SunOS 4, don't have EILSEQ. Some systems, like BSD/OS,\n   have EILSEQ in a different header.  On these systems, define EILSEQ\n   ourselves. */\n#ifndef EILSEQ\n#define EILSEQ EILSEQ\n#endif\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Allocates descriptor for code conversion from encoding ‘fromcode’ to\n   encoding ‘tocode’. */\n#ifndef LIBICONV_PLUG\n#define iconv_open libiconv_open\n#endif\nextern iconv_t iconv_open (const char* tocode, const char* fromcode);\n\n/* Converts, using conversion descriptor ‘cd’, at most ‘*inbytesleft’ bytes\n   starting at ‘*inbuf’, writing at most ‘*outbytesleft’ bytes starting at\n   ‘*outbuf’.\n   Decrements ‘*inbytesleft’ and increments ‘*inbuf’ by the same amount.\n   Decrements ‘*outbytesleft’ and increments ‘*outbuf’ by the same amount. */\n#ifndef LIBICONV_PLUG\n#define iconv libiconv\n#endif\nextern size_t iconv (iconv_t cd, const char* * inbuf, size_t *inbytesleft, char* * outbuf, size_t *outbytesleft);\n\n/* Frees resources allocated for conversion descriptor ‘cd’. */\n#ifndef LIBICONV_PLUG\n#define iconv_close libiconv_close\n#endif\nextern int iconv_close (iconv_t cd);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#ifndef LIBICONV_PLUG\n\n/* Nonstandard extensions. */\n\n#if USE_MBSTATE_T\n#if BROKEN_WCHAR_H\n/* Tru64 with Desktop Toolkit C has a bug: <stdio.h> must be included before\n   <wchar.h>.\n   BSD/OS 4.0.1 has a bug: <stddef.h>, <stdio.h> and <time.h> must be\n   included before <wchar.h>.  */\n#include <stddef.h>\n#include <stdio.h>\n#include <time.h>\n#endif\n#include <wchar.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* A type that holds all memory needed by a conversion descriptor.\n   A pointer to such an object can be used as an iconv_t. */\ntypedef struct {\n  void* dummy1[28];\n#if USE_MBSTATE_T\n  mbstate_t dummy2;\n#endif\n} iconv_allocation_t;\n\n/* Allocates descriptor for code conversion from encoding ‘fromcode’ to\n   encoding ‘tocode’ into preallocated memory. Returns an error indicator\n   (0 or -1 with errno set). */\n#define iconv_open_into libiconv_open_into\nextern int iconv_open_into (const char* tocode, const char* fromcode,\n                            iconv_allocation_t* resultp);\n\n/* Control of attributes. */\n#define iconvctl libiconvctl\nextern int iconvctl (iconv_t cd, int request, void* argument);\n\n/* Hook performed after every successful conversion of a Unicode character. */\ntypedef void (*iconv_unicode_char_hook) (unsigned int uc, void* data);\n/* Hook performed after every successful conversion of a wide character. */\ntypedef void (*iconv_wide_char_hook) (wchar_t wc, void* data);\n/* Set of hooks. */\nstruct iconv_hooks {\n  iconv_unicode_char_hook uc_hook;\n  iconv_wide_char_hook wc_hook;\n  void* data;\n};\n\n/* Fallback function.  Invoked when a small number of bytes could not be\n   converted to a Unicode character.  This function should process all\n   bytes from inbuf and may produce replacement Unicode characters by calling\n   the write_replacement callback repeatedly.  */\ntypedef void (*iconv_unicode_mb_to_uc_fallback)\n             (const char* inbuf, size_t inbufsize,\n              void (*write_replacement) (const unsigned int *buf, size_t buflen,\n                                         void* callback_arg),\n              void* callback_arg,\n              void* data);\n/* Fallback function.  Invoked when a Unicode character could not be converted\n   to the target encoding.  This function should process the character and\n   may produce replacement bytes (in the target encoding) by calling the\n   write_replacement callback repeatedly.  */\ntypedef void (*iconv_unicode_uc_to_mb_fallback)\n             (unsigned int code,\n              void (*write_replacement) (const char *buf, size_t buflen,\n                                         void* callback_arg),\n              void* callback_arg,\n              void* data);\n#if HAVE_WCHAR_T\n/* Fallback function.  Invoked when a number of bytes could not be converted to\n   a wide character.  This function should process all bytes from inbuf and may\n   produce replacement wide characters by calling the write_replacement\n   callback repeatedly.  */\ntypedef void (*iconv_wchar_mb_to_wc_fallback)\n             (const char* inbuf, size_t inbufsize,\n              void (*write_replacement) (const wchar_t *buf, size_t buflen,\n                                         void* callback_arg),\n              void* callback_arg,\n              void* data);\n/* Fallback function.  Invoked when a wide character could not be converted to\n   the target encoding.  This function should process the character and may\n   produce replacement bytes (in the target encoding) by calling the\n   write_replacement callback repeatedly.  */\ntypedef void (*iconv_wchar_wc_to_mb_fallback)\n             (wchar_t code,\n              void (*write_replacement) (const char *buf, size_t buflen,\n                                         void* callback_arg),\n              void* callback_arg,\n              void* data);\n#else\n/* If the wchar_t type does not exist, these two fallback functions are never\n   invoked.  Their argument list therefore does not matter.  */\ntypedef void (*iconv_wchar_mb_to_wc_fallback) ();\ntypedef void (*iconv_wchar_wc_to_mb_fallback) ();\n#endif\n/* Set of fallbacks. */\nstruct iconv_fallbacks {\n  iconv_unicode_mb_to_uc_fallback mb_to_uc_fallback;\n  iconv_unicode_uc_to_mb_fallback uc_to_mb_fallback;\n  iconv_wchar_mb_to_wc_fallback mb_to_wc_fallback;\n  iconv_wchar_wc_to_mb_fallback wc_to_mb_fallback;\n  void* data;\n};\n\n/* Requests for iconvctl. */\n#define ICONV_TRIVIALP            0  /* int *argument */\n#define ICONV_GET_TRANSLITERATE   1  /* int *argument */\n#define ICONV_SET_TRANSLITERATE   2  /* const int *argument */\n#define ICONV_GET_DISCARD_ILSEQ   3  /* int *argument */\n#define ICONV_SET_DISCARD_ILSEQ   4  /* const int *argument */\n#define ICONV_SET_HOOKS           5  /* const struct iconv_hooks *argument */\n#define ICONV_SET_FALLBACKS       6  /* const struct iconv_fallbacks *argument */\n\n/* Listing of locale independent encodings. */\n#define iconvlist libiconvlist\nextern void iconvlist (int (*do_one) (unsigned int namescount,\n                                      const char * const * names,\n                                      void* data),\n                       void* data);\n\n/* Canonicalize an encoding name.\n   The result is either a canonical encoding name, or name itself. */\nextern const char * iconv_canonicalize (const char * name);\n\n/* Support for relocatable packages.  */\n\n/* Sets the original and the current installation prefix of the package.\n   Relocation simply replaces a pathname starting with the original prefix\n   by the corresponding pathname with the current prefix instead.  Both\n   prefixes should be directory names without trailing slash (i.e. use \"\"\n   instead of \"/\").  */\nextern void libiconv_set_relocation_prefix (const char *orig_prefix,\n                                            const char *curr_prefix);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\n#endif /* _LIBICONV_H */\n"]],"start1":0,"start2":0,"length1":0,"length2":9345}]],"length":9345}
